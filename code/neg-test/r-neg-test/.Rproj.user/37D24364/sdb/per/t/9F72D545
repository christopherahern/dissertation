{
    "contents" : "#########################################################\n# This file contains utility functions for binning data\n#########################################################\ndo.by.year = function(df,n) {\n  # Split data into fixed-width time bins #\n  # df : data frame with two columns \n  # df$year : the year a given token occurs\n  # df$value : the binary value of the variants, by default 1 is the incoming variant\n  # n : number of fixed-width bins to split data into\n  ###\n  # Get start and end from data frame\n  start = min(df$year)\n  end = max(df$year)\n  # Get years for bins\n  df.bins = seq(start, end,(end - start)/n)\n  # Summarize data\n  sum.df = df %>% group_by(cut(year,df.bins, include.lowest=TRUE)) %>% summarize(value=sum(value), count=n())\n  # Rename columns\n  colnames(sum.df) = c('year','value','count')\n  # Replace ranges with midpoints\n  years = as.integer((head(df.bins,-1) + tail(df.bins,-1))/2)\n  sum.df$year = years\n  return(sum.df)\n}\noutput.binned = function(df, bin.method, out){\n  # Output binned data to file #\n  # df : data frame with three columns\n  # df$year : the midpoint year of a bin\n  # df$value : the number of tokens in a bin of variant 1\n  # df$count : the total number of tokens in a bin\n  # bin.method : use 'n' for fixed-width bins, 'q' for variable-width bins\n  # out : label for output file\n  ###\n  # Get the number of rows\n  n = nrow(df)\n  # Create name for file\n  name = paste(out, bin.method,sprintf(\"%02d\", n),\".data\",sep='')\n  # Print name to keep track of any errors\n  print(name)\n  # Write data frame to tab-separated file without row or column names\n  write.table(df,file=name,sep=\"\\t\",row.names=FALSE,col.names=FALSE) \n}\ndo.by.years = function(df, n, out) {\n  # Bin up to maximum number of bins and output files #\n  # df : data frame with same input as do.by.year\n  # n : maximum number of fixed-width bins\n  # out : label for output files\n  ###\n  for (i in c(2:n)) {\n    data = do.by.year(df, i)\n    output.binned(data, \"n\",out)\n  }  \n}\ndo.by.quantile = function(df,q) {\n  # Split data into varaible-width time bins #\n  # df : data frame with two columns \n  # df$year : the year a given token occurs\n  # df$value : the binary value of the variants, by default 1 is the incoming variant\n  # q : number of variable-width bins (qanttiles) to split data into\n  ###\n  # Get quantiles\n  df.quant = as.vector(quantile(df$year, probs=seq(0,1,1/q)))\n  # Summarize data\n  sum.df = df %>% dplyr::group_by(cut(year,df.quant, include.lowest=TRUE)) %>% dplyr::summarize(value=sum(value), count=n())\n  # Rename columns\n  colnames(sum.df) = c('year','value','count')\n  # Replace ranges with midpoints and filter data\n  years = as.integer((head(df.quant,-1) + tail(df.quant,-1))/2)\n  sum.df$year = years\n  return(sum.df)\n}\ndo.by.quantiles = function(df,q, out) {\n  # Bin up to maximum number of bins and output files #\n  # df : data frame with same input as do.by.year\n  # q : maximum number of bins\n  # out : label for output files\n  for (i in c(2:q)) {\n    data = do.by.quantile(df, i)\n    output.binned(data, \"q\", out)\n  }\n}\ncompare.q.n = function(df, n, max.height) {\n  # Plot comparison of fixed-width bins and quantiles\n  # df : data frame with year and value columns\n  # n : number of bins to compare\n  # max.height : the maximum height of the plot, set to multiple of nrows(df)\n  ###\n  # Get start and end from data frame\n  start = min(df$year)\n  end = max(df$year)\n  # Create fixed- and variable-width bins\n  bins = seq(start, end, (end - start)/n)\n  quants = as.vector(quantile(df$year, probs=seq(0,1,1/n)))\n  # Transform data given fixed- and variable-width bins\n  bin.df = df %>% group_by(cut(year,bins, include.lowest=TRUE)) %>% summarize(value=sum(value), count=n())\n  quant.df = df %>% group_by(cut(year,quants, include.lowest=TRUE)) %>% summarize(value=sum(value), count=n())\n  # Get the mean number of tokens per bin\n  data.mean = paste(\"mu == \", floor(mean(bin.df$count)))\n  # Get the standard deviations of tokens per bin for both kinds of binning methods\n  bin.sd = paste(\"sigma[n] ==\", floor(sd(bin.df$count)))\n  quant.sd = paste(\"sigma[q] ==\", floor(sd(quant.df$count)))\n  # Create histogram from both data kinds of bins\n  p = ggplot(df) +  geom_histogram(aes(x=year, y=..count.., alpha=.5), color=\"white\", fill=\"grey30\",  breaks = bins, right=TRUE) +  \n    geom_histogram(aes(x=year, y=..count.., alpha=.5),colour = \"black\", fill=\"white\", breaks = quants, right=TRUE) + \n    theme(legend.position=\"none\") +\n    ylab(\"Count\") + xlab(\"Year\") +\n    annotate(\"text\", label = paste(\"n = \", n,sep=\"\"), x = end - 100, y = max.height - 200, size = 8) + \n    annotate(\"text\", label = data.mean, x = end - 100, y = max.height - 600, size = 8, parse=T) + \n    annotate(\"text\", label = bin.sd, x = end - 100, y = max.height - 1000, size = 8, parse=T) + \n    annotate(\"text\", label = quant.sd, x = end - 100, y = max.height - 1400, size = 8, parse=T) + \n    theme(text = element_text(size=20)) +\n    coord_cartesian(ylim = c(0, max.height))\n  return(p)  \n}\n\n\nget.increments  = function(df, n) {\n  # Get the increments for the FIT test\n  # df : unbinned data\n  # n  : maximum number of increments\n  ###\n  # Create data frame to hold increments\n  out.df = NULL\n  # For each number of increments\n  for (i in 4:n){\n    this.data = do.by.quantile(df, i)\n    # Get number of bins from data\n    r = nrow(this.data)\n    # Create vector to hold fitness increments\n    Y = rep(0,(r-1))\n    # Get variant frequencies from df\n    v = this.data$value/this.data$count\n    # Get years from df\n    t = this.data$year\n    # Rescale increments according to definition\n    for (i in c(2:r)) { # R indexes from 1 rather than 0\n      Y[i-1] = (v[i] - v[i - 1])/sqrt(2*v[i-1]*(1 - v[i-1])*(t[i] - t[i-1]))\n    }\n    these.increments = cbind(rep(i, r-1), Y)\n    out.df = rbind(out.df, these.increments)\n  }  \n  colnames(out.df) = c(\"increments\", \"Yi\")\n  return(as.data.frame(out.df))\n}\n\n\ndo.FIT  = function(df) {\n  # Perform the FIT defind in Feder et al. 2013 #\n  # df : binned data frame with three columns\n  # df$year : the midpoint year of a bin\n  # df$value : the number of tokens in a bin of variant 1\n  # df$count : the total number of tokens in a bin\n  ###\n  # Get number of bins from data\n  n = nrow(df)\n  # Create vector to hold fitness increments\n  Y = rep(0,(n-1))\n  # Get variant frequencies from df\n  v = df$value/df$count\n  # Get years from df\n  t = df$year\n  # Rescale increments according to definition\n  for (i in c(2:n)) { # R indexes from 1 rather than 0\n    Y[i-1] = (v[i] - v[i - 1])/sqrt(2*v[i-1]*(1 - v[i-1])*(t[i] - t[i-1]))\n  }\n#   print(Y)\n  # Mean fitness increment\n  Y.bar = mean(Y)\n  # Get t statistic from rescaled fitness increments\n  stat = as.numeric(t.test(Y, alternative=\"greater\")$statistic)\n  # p value for t-test : H_0 is that the mean of rescaled increments are not greater than zero\n  p = t.test(Y, alternative=\"greater\")$p.value\n  # Get mean number of tokens per bin\n  mu = floor(mean(df$count))\n  # Get standard deviation of tokens across bins\n  sigma = floor(sd(df$count))\n  # p value of shapiro-wilk test : H_0 is that rescaled increments are normally distributed\n  w = shapiro.test(Y)$p.value\n  # p value of wilcoxon test : H_0 is that the rescaled increments are \n  x = wilcox.test(Y, alternative=\"greater\")$p.value\n  # Create vector that leaves room for including data from tsinfer\n  values = c(n, 0, 0, 0, Y.bar, stat, p, mu, sigma, w, x)\n  return(values)\n}\nn.table = function(df, n) {\n  # Generate table for FIT information up to n fixed-with bins#\n  return.df = NULL\n  for (i in c(4:n)){\n#     print(i)\n    this.data = do.by.year(df, i)\n    return.df = rbind(return.df, do.FIT(this.data))\n  }\n  return.df = as.data.frame(return.df)\n  colnames(return.df) = c(\"Bins\", \"MLs\", \"MLalpha\",\"LRT.P\",\"Y.bar\", \"t.FIT\",\"FIT.P\", \"mu\", \"sigma\", \"SW.P\")\n  return(return.df)\n}\nq.table = function(df, n) {\n  # Generate table for FIT information up to n fixed-with bins#\n  return.df = NULL\n  for (i in c(4:n)){\n    this.data = do.by.quantile(df, i)\n    do.FIT(this.data)\n    return.df = rbind(return.df, do.FIT(this.data))\n  }\n  return.df = as.data.frame(return.df)\n  colnames(return.df) = c(\"Bins\", \"MLs\", \"MLalpha\",\"LRT.P\",\"Y.bar\", \"t.FIT\",\"FIT.P\", \"mu\", \"sigma\", \"SW.P\", \"WX.p\")\n  return(return.df)\n}\n\n# Generate tables for the number of documents per bin\nn.doc = function(df, n){\n  start = min(df$year)\n  end = max(df$year)\n  df.bins = seq(start, end, (end - start)/n)\n  n.df = df %>% group_by(cut(year,df.bins, include.lowest=TRUE)) %>% summarize(doc=n_distinct(TextName))\n  years = as.integer((head(df.bins,-1) + tail(df.bins,-1))/2)\n  n.df$year = years\n  # reutrn min, max, mean, and sd\n  return(c(n, min(n.df$doc), max(n.df$doc), mean(n.df$doc), sd(n.df$doc)))\n}\nn.docs = function(df, n){\n  return.df = NULL\n  for (i in c(4:n)){\n    return.df = rbind(return.df, n.doc(df, i))\n  }\n  return.df = as.data.frame(return.df)\n  colnames(return.df) = c(\"Bins\", \"min\", \"max\", \"mean\",\"sd\")\n  return(return.df)\n}\nq.doc = function(df, q){\n  df.quant = as.vector(quantile(df$year, probs=seq(0,1,1/q)))\n  q.df = df %.% dplyr::group_by(cut(year,df.quant, include.lowest=TRUE)) %.% dplyr::summarize(auth=n_distinct(TextName))\n  years = as.integer((head(df.quant,-1) + tail(df.quant,-1))/2)\n  q.df$year = years\n  # reutrn min, max, mean, and sd\n  return(c(q, min(q.df$auth), max(q.df$auth), mean(q.df$auth), sd(q.df$auth)))\n}\nq.docs = function(df, q){\n  return.df = NULL\n  for (i in c(4:q)){\n    return.df = rbind(return.df, q.doc(df, i))\n  }\n  return.df = as.data.frame(return.df)\n  colnames(return.df) = c(\"Bins\", \"min\", \"max\", \"mean\",\"sd\")\n  return(return.df)\n}\nn.auth = function(df, n){\n  start = min(df$year)\n  end = max(df$year)\n  df.bins = seq(start, end, (end - start)/n)\n  n.df = df %>% group_by(cut(year,df.bins, include.lowest=TRUE)) %>% summarize(doc=n_distinct(AuthName))\n  years = as.integer((head(df.bins,-1) + tail(df.bins,-1))/2)\n  n.df$year = years\n  # reutrn min, max, mean, and sd\n  return(c(n, min(n.df$doc), max(n.df$doc), mean(n.df$doc), sd(n.df$doc)))\n}\nn.auths = function(df, n){\n  return.df = NULL\n  for (i in c(4:n)){\n    return.df = rbind(return.df, n.auth(df, i))\n  }\n  return.df = as.data.frame(return.df)\n  colnames(return.df) = c(\"Bins\", \"min\", \"max\", \"mean\",\"sd\")\n  return(return.df)\n}\nq.auth = function(df, q){\n  df.quant = as.vector(quantile(df$year, probs=seq(0,1,1/q)))\n  q.df = df %.% dplyr::group_by(cut(year,df.quant, include.lowest=TRUE)) %.% dplyr::summarize(auth=n_distinct(AuthName))\n  years = as.integer((head(df.quant,-1) + tail(df.quant,-1))/2)\n  q.df$year = years\n  # reutrn min, max, mean, and sd\n  return(c(q, min(q.df$auth), max(q.df$auth), mean(q.df$auth), sd(q.df$auth)))\n}\nq.auths = function(df, q){\n  return.df = NULL\n  for (i in c(4:q)){\n    return.df = rbind(return.df, q.auth(df, i))\n  }\n  return.df = as.data.frame(return.df)\n  colnames(return.df) = c(\"Bins\", \"min\", \"max\", \"mean\",\"sd\")\n  return(return.df)\n}\n\n",
    "created" : 1431555441436.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2130025297",
    "id" : "9F72D545",
    "lastKnownWriteTime" : 1427392487,
    "path" : "~/Dropbox/dissertation/code/neg-test/r-neg-test/binning.R",
    "project_path" : "binning.R",
    "properties" : {
    },
    "relative_order" : 0,
    "source_on_save" : false,
    "type" : "r_source"
}