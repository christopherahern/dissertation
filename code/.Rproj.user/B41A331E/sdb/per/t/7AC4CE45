{
    "contents" : "library(ggplot2)\nlibrary(dplyr)\nlibrary(reshape)\n\n# Finding relation between logistic and LRP\nf = function(x, a, b) x*(1-x)*((b - a)/(a*(1-x)+b*x))\nfa = function(x, a, b) x*(1-x)*((b - a)/a) # upper curve\nfb = function(x, a, b) x*(1-x)*((b - a)/b) # lower curve\nfr = function(x, Q, B, M, v) B*Q*(Q*exp(-B*(-M + x)) + 1)**(-1/v)*exp(-B*(-M + x))/(v*(Q*exp(-B*(-M + x)) + 1))\n# k*((delta - 1)*exp(k*(-x + 0.309016994374947)) + 1)**(-delta/(delta - 1))*exp(k*(-x + 0.309016994374947))\n# s = function(x,a,v) a*(1-x^v)*x\n\ncurve(f(x, .1, .5), xlim=c(0,1), xlab='p', ylab=expression(dot(p)))\ncurve(fr(x, 1, 2, .5, 2), add=T)\ncurve(fr(x, 2, 2, .5, 2), add=T)\n\n\n\n\n# Try this out for differen parameters\n# a=.1, b=.5\npar(mar=c(5,5.4,4.1,2.1))\ncurve(fa(x, .1, .5), xlim=c(0,1), xlab='p', ylab=expression(dot(p)))\ncurve(fb(x, .1, .5), add=T)\ncurve(f(x, .1, .5),  add=T)\ntext(.2, .8, expression(dot(p)[alpha]))\ntext(.2, .05, expression(dot(p)[beta]))\ntext(.2, .4, expression(dot(p)))\n# a=.5,b=.1\ncurve(fb(x, .5, .1), xlim=c(0,1), xlab='p', ylab=expression(dot(p)))\ncurve(fa(x, .5, .1), xlim=c(0,1), add=T)\ncurve(f(x, .5, .1), xlim=c(0,1), add=T)\n# Plot solution for parameters and initial solution  for NB: x=t\nga = function(x, a, b, x0) ((x0/(1-x0))*exp(x*(b - a)/a))/(1 + (x0/(1-x0))*exp(x*(b - a)/a))\ngb = function(x, a, b, x0) ((x0/(1-x0))*exp(x*(b - a)/b))/(1 + (x0/(1-x0))*exp(x*(b - a)/b))\ncurve(ga(x, .1, .5, .01), xlim=c(0,10), xlab='t', ylab='p')\ncurve(gb(x, .1, .5, .01), xlim=c(0,10), add=T)\ntext(1, .8, expression(p[alpha]))\ntext(4, .05, expression(p[beta]))\n\n\ncurve(g(x, .1, .5), xlim=c(0,1), xlab='p', ylab=expression(dot(p)))\ncurve(r(), add=T)\n\n\n\n\ntext(.2, .8, expression(dot(p)[alpha]))\ntext(.2, .05, expression(dot(p)[beta]))\ntext(.2, .4, expression(dot(p)))\n\n\n           \n\n# Let's try discrete version\ng = function(a,b,x) a*x/(a*x + b*(1-x)) - x\ngenerate.p = function(init.p,a,b,n) {\n  vector = rep(0, n)\n  vector[1] = init.p\n  for (i in 2:n){\n    vector[i] = vector[i-1] + g(a,b,vector[i-1])\n  }\n  return(vector)\n}\n\ntest = generate.p(.01, .5, .1, 10)\nplot(test, ylim=c(0,1), xlab=\"Time\", ylab=expression(\"p\"[\"not\"]), type=\"l\", cex.lab=2)\ntext(3,.8, expression(frac(beta, alpha) > 1), cex=2)\n\n\n\nft = function(x, a, b) .5*fa(x, a, b) +  .5*fb(x,a,b)\n# Let's try to find the form\ncurve(ft(x, .1,.5), xlim=c(0,1),add=T)\nFa = integrate(fa, lower=0, upper=1, x=x)\n# http://stackoverflow.com/questions/22274275/compute-multiple-integral-and-plot-them-with-r\n\n\np = seq(0,1,.001)\nf = function(a,b,x) a*x/(a*x + b*(1-x))\nplot(p, f(.5, .1,p))\nabline(0,1, lty=2)\ng = function(a,b,x) a*x/(a*x + b*(1-x)) - x\nplot(p, g(.5, .1,p), ylim=c(0,1))\nabline(0,1, lty=2)\nh = function(a,b,x) -a*b*log(a*b - b**2 + x*(a**2 - 2*a*b + b**2))/(a - b)**2 + a*x/(a - b) - x**2/2\nplot(p, h(.5, .1,p), ylim=c(0,2))\nabline(0,1, lty=2)\n\ngenerate.p = function(init.p,a,b,n) {\n  vector = rep(0, n)\n  vector[1] = init.p\n  for (i in 2:n){\n    vector[i] = vector[i-1] + g(a,b,vector[i-1])\n  }\n  return(vector)\n}\n\ngenerate.q = function(init.p,a,b,n) {\n  vector = rep(0, n)\n  vector[1] = init.p\n  for (i in 2:n){\n    vector[i] = vector[i-1] + g(a,b,vector[i-1])*(i/n)\n  }\n  return(vector)\n}\nq.test = generate.q(.1, .8, .3, 10)\npar(mar=c(5,5.4,4.1,2.1))\nplot(q.test, ylim=c(0,1), xlab=\"Time\", ylab=expression(\"p\"[\"neg V neg\"]), type=\"l\", cex.lab=2)\ntext(3,.8, expression(b > frac(1,4)), cex=2)\n\npar(mar=c(5,5,4.1,2.1))\ntest = generate.p(.01, .9, .2, 10)\nplot(test, ylim=c(0,1), xlab=\"Time\", ylab=expression(\"p\"[\"not\"]), type=\"l\", cex.lab=2)\ntext(3,.8, expression(frac(beta, alpha) > 1), cex=2)\n\ntest = generate.p(.1, .2, .9, 10)\nplot(test, ylim=c(0,1), xlab=\"Time\", ylab=expression(\"p\"[\"not\"]), type=\"l\", cex.lab=2)\ntext(3,.8, expression(frac(beta, alpha) < 1), cex=2)\n\nx <- seq(0, 1, length=100)\nhx <- dbeta(x, 1, 3)\nplot(x, hx, type=\"l\", xlab=\"T\", ylab='Density', axes=F)\nAxis(side=1, at=c(0,1))\n# Axis(side=2, at=c(0,3))\nlibrary(ggplot2)\nx <- seq(0, 1, len = 100)\np <- qplot(x, geom = \"blank\")\nstat <- stat_function(aes(x = x, y = ..y..), fun = dbeta, colour=\"red\", n = 1000,\n                      args = list(shape1 = 1, shape2 = 3))\np + stat\n\n\n# Drift 1\ndrift1.full = read.csv('drift1.csv', header=T, sep=\",\")\ndrift1 = data.frame(time = as.numeric(drift1.full$x),\n                    blue = as.numeric(drift1.full$y),\n                    red = as.numeric(drift1.full$y.1))\ndrift1 = tbl_df(drift1)\ndrift1 = drift1 %>% mutate(total = blue + red) %>% mutate(blue.p = blue/total) %>% mutate(red.p = red/total)\n  \nggplot() + geom_line(data=drift1, aes(x=time, y=blue.p), color='blue') + \n  geom_line(data=drift1, aes(x=time, y=red.p), color='red') + ylab(\"Proportion\") + xlab(\"Time\") +     theme(text = element_text(size=20))\n\n\n# Drift 2\ndrift2.full = read.csv('drift2.csv', header=T, sep=\",\")\ndrift2 = data.frame(time = as.numeric(drift2.full$x),\n                    blue = as.numeric(drift2.full$y),\n                    red = as.numeric(drift2.full$y.1))\ndrift2 = tbl_df(drift2)\ndrift2 = drift2 %>% mutate(total = blue + red) %>% mutate(blue.p = blue/total) %>% mutate(red.p = red/total)\n\nggplot() + geom_line(data=drift2, aes(x=time, y=blue.p), color='blue') + \n  geom_line(data=drift2, aes(x=time, y=red.p), color='red') + ylab(\"Proportion\") + xlab(\"Time\") +     theme(text = element_text(size=20))\n\n# Drift 3\ndrift3.full = read.csv('drift3.csv', header=T, sep=\",\")\ndrift3 = data.frame(time = as.numeric(drift3.full$x),\n                    blue = as.numeric(drift3.full$y),\n                    red = as.numeric(drift3.full$y.1))\ndrift3 = tbl_df(drift3)\ndrift3 = drift3 %>% mutate(total = blue + red) %>% mutate(blue.p = blue/total) %>% mutate(red.p = red/total)\n\nggplot() + geom_line(data=drift3, aes(x=time, y=blue.p), color='blue') + scale_x_continuous(limits=c(0,6000),breaks=c(0, 1000, 2000, 3000, 4000, 5000, 6000)) + \n  geom_line(data=drift3, aes(x=time, y=red.p), color='red') + ylab(\"Proportion\") + xlab(\"Time\") +     theme(text = element_text(size=20))\n\n# Selection 1\nselection1.full = read.csv('selection1.csv', header=T, sep=\",\")\nselection1 = data.frame(time = as.numeric(selection1.full$x),\n                    blue = as.numeric(selection1.full$y),\n                    red = as.numeric(selection1.full$y.1))\nselection1 = tbl_df(selection1)\nselection1 = selection1 %>% mutate(total = blue + red) %>% mutate(blue.p = blue/total) %>% mutate(red.p = red/total)\n\nggplot() + geom_line(data=selection1, aes(x=time, y=blue.p), color='blue') + scale_x_continuous(breaks=c(0, 1000, 2000, 3000, 4000, 5000, 6000)) + \n  geom_line(data=selection1, aes(x=time, y=red.p), color='red') + ylab(\"Proportion\") + xlab(\"Time\") +     theme(text = element_text(size=20))\n# Selection 2\nselection2.full = read.csv('selection2.csv', header=T, sep=\",\")\nselection2 = data.frame(time = as.numeric(selection2.full$x),\n                        blue = as.numeric(selection2.full$y),\n                        red = as.numeric(selection2.full$y.1))\nselection2 = tbl_df(selection2)\nselection2 = selection2 %>% mutate(total = blue + red) %>% mutate(blue.p = blue/total) %>% mutate(red.p = red/total)\n\nggplot() + geom_line(data=selection2, aes(x=time, y=blue.p), color='blue') + \n  geom_line(data=selection2, aes(x=time, y=red.p), color='red') + ylab(\"Proportion\") + xlab(\"Time\") +     theme(text = element_text(size=20))\n\n# Generate map for plotting languages involved with Jespersen's Cycle\nlibrary(ggmap)\nlibrary(mapproj)\njc.data = read.csv(file='~/Dropbox/ucsd/code/test.csv',header=T)\nnewmap <- getMap(resolution = \"low\")\nplot(newmap)\npoints(jc.data$longitude, jc.data$latitude, col = \"red\", cex = .6, pch=16)\n#############################################################################\nlibrary(VGAM)\n# Beta-binomial distribution where alpha=1, beta=2, and n=100\nt.probs = dbetabinom.ab(x=1:100, size=100, shape1=1, shape2=2)\n# Cumulative distribution is roughly 10% matching starting state when t^* = 68\nsum(t.probs[68:100])\n# Create initial distributions\nepsilon = .05 # epsilon is distributed to other strategies\ns.probs = rep(epsilon/100, 100)\ns.probs[68] = 1 - (99/100)*epsilon # sum(s.probs) length(s.probs)\nm1.probs = rep(epsilon/100, 100)\nm1.probs[84] = 1 - (99/100)*epsilon # sum(m1.probs) length(m1.probs)\nm2.probs = rep(epsilon/100, 100)\nm2.probs[34] = 1 - (99/100)*epsilon # sum(m2.probs) length(m2.probs)\n\nb=.2\n# Sender expected utilities\nEU.s = rep(0, 100)\nfor (s in c(1:100)){\n  print(s)\n  t.star = s/100\n  # sending message m1\n  EU.s.m1 = NULL\n  for (t in c(1:s)){\n    for (a in c(1:100)){\n      EU.s.m1 = append(EU.s.m1, t.probs[t]*m1.probs[a]*(1 - (t/100 - a/100 - (1-t/100)*b )**2))\n    }    \n  }\n  # sending message m2\n  EU.s.m2 = NULL  \n  for (t in c(1:s)){\n    for (a in c(1:100)){\n      EU.s.m2 = append(EU.s.m2, t.probs[t]*m2.probs[a]*(1 - (t/100 - a/100 - (1-t/100)*b )**2))\n    }    \n  }\n  EU.s[s] = sum(EU.s.m1) + sum(EU.s.m2)\n}\n\nplot(EU.s)\n\n# Discrete-time Replicator equation\nx,i.next = x.i*(s.i/s.bar) # proportion of x.i at next point in time is proportion times fitness divided by average fitness\n\n\nlibrary(VGAM)\n# Plot distribution over coherence relations\ns1 = dbetabinom.ab(x=1:100, size=100, shape1=4, shape2=2)\npar(mar=c(5,5.4,4.1,2.1))\nhist(s1, yaxt='n', ylab='Count', xaxt='n', xlab='Coherence relation given negation', main='', cex.lab=1.5)\n#plot(s1, type='l', yaxt='n', ylab='', xaxt='n', xlab='Coherence Relation given Negation')\nhelp(dbeta)\ns2 = sort(rbeta(10000, 3, 2))\ns2 = dbeta(size=100, shape1=3, shape2=2)\nplot(s2, type='l', yaxt='n', ylab='', xlab='Discourse Status')\ns3 = dbetabinom.ab(x=1:100, size=100, shape1=2, shape2=2)\nplot(s3, type='l', yaxt='n', ylab='', xaxt='n', xlab='Discourse Status')\n\n",
    "created" : 1427404168310.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "500476140",
    "id" : "7AC4CE45",
    "lastKnownWriteTime" : 1427907539,
    "path" : "~/Dropbox/dissertation/code/plots.R",
    "project_path" : "plots.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}